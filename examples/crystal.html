

<html>

<head>
  <style>

    html{ color:#fff; }

    #container{
      width      : 100%;
      height     : 100%;
      position   : absolute;
      top        : 0px;
      left       : 0px;
      background : #000;
    }

    #stats{
      position  : absolute;
      bottom    : 0px;
      right     : 0px;
      z-index   : 999;
    }

  </style>
</head>
<body>

  
<script src = "../lib/leap.js"                ></script>
<script src = "../lib/three.js"               ></script>
<script src = "../lib/jquery.min.js"          ></script>
<script src = "../lib/stats.min.js"           ></script>
<script src = "../lib/TrackballControls.js"   ></script>
<script src = "../lib/ShaderLoader.js"        ></script>
<script src = "../lib/OBJLoader.js"           ></script>
<script src = "../lib/ObjectControls.js"      ></script>

<script src = "../RiggedSkeleton.js"          ></script>

<script src = "js/Crystal.js"                 ></script>
<script src = "js/Mirror.js"                 ></script>


<script>

  // Global Variables for THREE.JS
  var container , camera, scene, renderer , stats;

  // Global variable for leap
  var frame, controller;

  // our rigged skeleton
  var riggedSkeleton;

  var sceneSize = 100;

  init();
  animate();

  function init(){

    controller = new Leap.Controller();

    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera( 
      50 ,
      window.innerWidth / window.innerHeight,
      sceneSize / 100 ,
      sceneSize * 40
    );

    // placing our camera position so it can see everything
    camera.position.z = sceneSize *9;

     riggedSkeleton = new RiggedSkeleton( controller , {

      movementSize: 500,
      handSize: 100
      
    });


    //riggedSkeleton.addScaledJointMesh( mesh , 'distal' );
    riggedSkeleton.addToScene( scene );

    var handMesh = new THREE.Mesh(
      new THREE.BoxGeometry( 10 , 10 , 100 ),
      new THREE.MeshPhongMaterial({color:0xffffff})
    );

    riggedSkeleton.addScaledJointMesh( handMesh , 'intermediate' );
    riggedSkeleton.addScaledJointMesh( handMesh , 'distal' );
    riggedSkeleton.addScaledJointMesh( handMesh , 'proximal' );
    riggedSkeleton.addScaledJointMesh( handMesh , 'metacarpal' );

    riggedSkeleton1 = new RiggedSkeleton( controller , {

      movementSize: 500,
      handSize: 100
      
    });


    //riggedSkeleton1.addScaledJointMesh( mesh , 'distal' );
    riggedSkeleton1.addToScene( scene );

    var handMesh = new THREE.Mesh(
      new THREE.BoxGeometry( 10 , 10 , 100 ),
      new THREE.MeshPhongMaterial({color:0xffffff})
    );

    riggedSkeleton1.addScaledJointMesh( handMesh , 'intermediate' );
    riggedSkeleton1.addScaledJointMesh( handMesh , 'distal' );
    riggedSkeleton1.addScaledJointMesh( handMesh , 'proximal' );
    riggedSkeleton1.addScaledJointMesh( handMesh , 'metacarpal' );



    objectControls = new ObjectControls( camera,  riggedSkeleton.hand , riggedSkeleton1.hand ,controller );
    

    cubeCamera = new THREE.CubeCamera(1, 1000, 256); // parameters: near, far, resolution
    cubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter; // mipmap filter

    scene.add(cubeCamera);

    // create a mesh with cubeCamera.renderTarget as a value of envMap
    sphere = new THREE.Mesh(
      new THREE.SphereGeometry(20, 30, 15),
      new THREE.MeshBasicMaterial({
        envMap: cubeCamera.renderTarget,
      })
    );

    cubeCamera.position = sphere.position;

    objectControls.add( sphere );

    scene.add( sphere );
    sphere.position.x = -200;
    sphere.position.y = -50;

    
    var light = new THREE.PointLight( 0xffcc66 , 2 , 300 );
    scene.add( light );

    light.position = sphere.position;



    cubeCamera1 = new THREE.CubeCamera(1, 1000, 256); // parameters: near, far, resolution
    cubeCamera1.renderTarget.minFilter = THREE.LinearMipMapLinearFilter; // mipmap filter

    scene.add(cubeCamera1);

    // create a mesh with cubeCamera.renderTarget as a value of envMap
    sphere1 = new THREE.Mesh(
      new THREE.SphereGeometry(20, 30, 15),
      new THREE.MeshBasicMaterial({
        envMap: cubeCamera1.renderTarget,
      })
    );

    cubeCamera1.position = sphere1.position;


    objectControls.add( sphere1 );
    scene.add( sphere1 );
    sphere1.position.y = -50;


    var light1 = new THREE.PointLight( 0x66ffcc , 2 , 300);
    scene.add( light1 );

    light1.position = sphere1.position;



    cubeCamera2 = new THREE.CubeCamera(1, 1000, 256); // parameters: near, far, resolution
    cubeCamera2.renderTarget.minFilter = THREE.LinearMipMapLinearFilter; // mipmap filter

    scene.add(cubeCamera2);

    // create a mesh with cubeCamera.renderTarget as a value of envMap
    sphere2 = new THREE.Mesh(
      new THREE.SphereGeometry(20, 30, 15),
      new THREE.MeshBasicMaterial({
        envMap: cubeCamera2.renderTarget,
      })
    );


    cubeCamera2.position = sphere2.position;
    objectControls.add( sphere2 );
    scene.add( sphere2 );
    sphere2.position.x = 200;
    sphere2.position.y = -50;

    var light2 = new THREE.PointLight( 0xff66cc , 2 , 300 );
    scene.add( light2 );

    light2.position = sphere2.position;

          


    controls = new THREE.TrackballControls( camera );

    // Getting the container in the right location
    container     = document.createElement( 'div' );
    container.id  = 'container';
    
    document.body.appendChild( container );


    // Getting the stats in the right position
    stats = new Stats();
    stats.domElement.id = 'stats';
    document.body.appendChild( stats.domElement );


    // Setting up our Renderer
    renderer = new THREE.WebGLRenderer({antialias:true});

    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );


    // Making sure our renderer is always the right size
    window.addEventListener( 'resize', onWindowResize , false );


    
    controller.connect();

    crystal = new Crystal( 100 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;
    scene.add( crystal );


    crystal = new Crystal( 100 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );

     crystal = new Crystal( 100 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );


     crystal = new Crystal( 100 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );


     crystal = new Crystal( 100 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );


    crystal = new Crystal( 100 , 60 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );

    crystal = new Crystal( 400 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );

    crystal = new Crystal( 40 , 150 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );

    crystal = new Crystal( 80 , 100 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal );

    crystal = new Crystal( 200 , 15 ,  100 );

    crystal.rotation.x = Math.PI/2;
    crystal.position.z = (Math.random()-.5) * 300;
    crystal.position.x = (Math.random()-.5) * 300;
    crystal.position.y = -201;

    scene.add( crystal )


    


    groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: window.innerWidth, textureHeight: window.innerHeight, color: 0x777777 } );
		
	var planeGeo = new THREE.PlaneGeometry( 3000, 3000, 100 , 100 );

    mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material );
    mirrorMesh.add( groundMirror );
    mirrorMesh.rotateX( -Math.PI / 2 );
    scene.add( mirrorMesh );
    mirrorMesh.position.y = -190;


    //scene.add( crystal );

  }

  function animate(){

    controls.update();
    riggedSkeleton.update(0);
    riggedSkeleton1.update(1);

    stats.update();

    //dT.value = clock.getDelta();
    //timer.value += dT.value;


    objectControls.update();
    
    sphere.visible = false;
    cubeCamera.updateCubeMap(renderer, scene);
    sphere.visible = true;

    sphere1.visible = false;
    cubeCamera1.updateCubeMap(renderer, scene);
    sphere1.visible = true;

    sphere2.visible = false;
    cubeCamera2.updateCubeMap(renderer, scene);
    sphere2.visible = true;

    groundMirror.render();
    renderer.render( scene , camera );



       requestAnimationFrame( animate );

  }

  // Resets the renderer to be the proper size
  function onWindowResize(){

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

</script>

</body>
</html>
