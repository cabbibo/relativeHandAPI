<html>

<head>
  <style>

    html{ color:#fff; }

    #container{
      width      : 100%;
      height     : 100%;
      position   : absolute;
      top        : 0px;
      left       : 0px;
      background : #000;
    }

    #stats{
      position  : absolute;
      bottom    : 0px;
      right     : 0px;
      z-index   : 999;
    }

    a{
color: #fff;
position: absolute;
z-index: 999;

    }
  </style>
</head>
<body>


<script src = "../lib/leap.js"                ></script>
<script src = "../lib/three.js"               ></script>
<script src = "../lib/jquery.min.js"          ></script>
<script src = "../lib/stats.min.js"           ></script>
<script src = "../lib/TrackballControls.js"   ></script>
<script src = "../lib/ShaderLoader.js"        ></script>
<script src = "../lib/OBJLoader.js"           ></script>
<script src = "../lib/Stream.js"              ></script>
<script src = "../lib/AudioController.js"     ></script>
<script src = "../lib/AudioTexture.js"        ></script>

<script src = "../RiggedSkeleton.js"          ></script>


<script>

  // Global Variables for THREE.JS
  var container , camera, scene, renderer , stats;

  // Global variable for leap
  var frame, controller;

  // Setting up how big we want the scene to be
  var sceneSize = 3000;

  var skullGeo;
  var boneGeo;

  var loaded = 0;
  var neededToLoad = 3;


  var clock = new THREE.Clock();


  var audioController = new AudioController();

  var stream = new Stream(  '../audio/you.mp3',audioController  );


  var loader  = new THREE.OBJLoader();
  loader.load( '../models/totem_6.OBJ' , function( obj ){

    boneGeo = obj.children[0].geometry//.geometry;
    console.log( boneGeo );
    onLoad();

    boneGeo.computeFaceNormals();
    boneGeo.computeVertexNormals();

  });

  //Eye_ship_50k_tris.OBJ 
  //cyber_bug_Mk1_93k_tris.OBJ
  //totem_6.obj
  //skull1.obj

  loader.load( '../models/cyber_bug_Mk1_93k_tris.OBJ' , function( obj ){

    console.log( obj );
    skullGeo = obj.children[0].geometry//.geometry;
    console.log( skullGeo );

    skullGeo.computeFaceNormals();
    skullGeo.computeVertexNormals();

    onLoad();

  });


  var timer = { type:"f" , value:0 }


  var shaders = new ShaderLoader('../shaders');

  shaders.load( 'fs-iri' , 'iri' , 'fragment' );
  shaders.load( 'vs-iri' , 'iri' , 'vertex' );
  shaders.load( 'fs-planet' , 'planet' , 'fragment' );
  shaders.load( 'vs-planet' , 'planet' , 'vertex' );

  shaders.shaderSetLoaded = function(){
   onLoad();
  }
 
  function init(){

    controller = new Leap.Controller();

    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera( 
      50 ,
      window.innerWidth / window.innerHeight,
      sceneSize / 100 ,
      sceneSize * 40
    );

    // placing our camera position so it can see everything
    camera.position.z = sceneSize ;


    controls = new THREE.TrackballControls( camera );

    // Getting the container in the right location
    container     = document.createElement( 'div' );
    container.id  = 'container';
    
    document.body.appendChild( container );


    // Getting the stats in the right position
    stats = new Stats();
    stats.domElement.id = 'stats';
    document.body.appendChild( stats.domElement );


    // Setting up our Renderer
    renderer = new THREE.WebGLRenderer();

    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );


    // Making sure our renderer is always the right size
    window.addEventListener( 'resize', onWindowResize , false );


    var light = new THREE.DirectionalLight( 0xaaaaff , 1);
    light.position.set( 0 , 0 , 1 );
    scene.add( light );

     var light = new THREE.DirectionalLight( 0xffaaaa , 1);
    light.position.set( 0 , 1 , 0 );
    scene.add( light );


     var light = new THREE.DirectionalLight( 0xaaffaa , 1);
    light.position.set( 1 , 0 , 0 );
    scene.add( light );

  
    var tNormal = THREE.ImageUtils.loadTexture( '../img/normals/moss_normal_map.jpg' );
    tNormal.wrapS = THREE.RepeatWrapping; 
    tNormal.wrapT = THREE.RepeatWrapping; 
    console.log( 'TNOMAL');
    console.log( tNormal );

    var tLookup = THREE.ImageUtils.loadTexture( '../img/iriLookup.png' );

    var color1 = new THREE.Vector3( 1. , 1. , .3 );
    var color2 = new THREE.Vector3( 5. , 2. , 0 );
    var color3 = new THREE.Vector3( 1. , .4 , 0. );
    var color4 = new THREE.Vector3( 0. , 1. , 6. );

    
    var uniforms = {

      lightPos: { type:"v3" , value: new THREE.Vector3(100,0,0)},
      tNormal:{type:"t",value:tNormal},
      time:timer,
      tLookup:{ type:"t" , value: tLookup },
      t_audio:{ type:"t" , value: audioController.texture },
      color1:{ type:"v3" , value: color1 },
      color2:{ type:"v3" , value: color2 },
      color3:{ type:"v3" , value: color3 },
      color4:{ type:"v3" , value: color4 },

    }



    vertexShader   = shaders.vertexShaders.planet;
    fragmentShader = shaders.fragmentShaders.planet;

    material = new THREE.ShaderMaterial({

      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader

    });

    mesh = new THREE.Mesh( skullGeo , material );
    scene.add( mesh );

    mesh.scale.multiplyScalar( 400.2 );
    mesh.rotation.x = -Math.PI/2

    mesh.position.y = 50;

    

    var color1 = new THREE.Vector3( .1 , 3. , 1. );
    var color2 = new THREE.Vector3( .4 , 2. , 0 );
    var color3 = new THREE.Vector3( .2 , .4 , 5. );
    var color4 = new THREE.Vector3( 10. , .1 , .6 );

    
    var uniforms = {

      lightPos: { type:"v3" , value: new THREE.Vector3(100,0,0)},
      tNormal:{type:"t",value:tNormal},
      time:timer,
      tLookup:{ type:"t" , value: tLookup },
      t_audio:{ type:"t" , value: audioController.texture },
      color1:{ type:"v3" , value: color1 },
      color2:{ type:"v3" , value: color2 },
      color3:{ type:"v3" , value: color3 },
      color4:{ type:"v3" , value: color4 },

    }



    vertexShader   = shaders.vertexShaders.planet;
    fragmentShader = shaders.fragmentShaders.planet;

    material = new THREE.ShaderMaterial({

      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader

    });


    mesh = new THREE.Mesh( boneGeo , material );

    mesh.scale.multiplyScalar( 40.5 );
    

    meshes=[];
    for( var i = 0; i < 10; i++ ){

      var t = (i-1.5) /12;

      var x = 700 * Math.cos( t * 2 * Math.PI );
      var y = 700 * Math.sin( t * 2 * Math.PI );

      var m = mesh.clone();
      m.position.x = x;
      m.position.y = y;
    //  m.rotation.y = Math.PI / 2;
      m.rotation.z = ( t * Math.PI * 2 ) - Math.PI / 2;

      scene.add( m );

      meshes.push( m );


    }

 
  //scene.add( mesh );

    controller.connect();


  }


  function animate(){

    audioController.update();
    timer.value += clock.getDelta();

    controls.update();
    //riggedSkeletons[ currentRiggedSkeleton ].update();

    stats.update();

    renderer.render( scene , camera );

    requestAnimationFrame( animate );

    for( var i = 0; i < meshes.length; i++ ){

      //meshes[i].rotation.x += .006;
      //meshes[i].rotation.y += .009;
     // meshes[i].rotation.z += .004;


    }

  }

  // Resets the renderer to be the proper size
  function onWindowResize(){

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

 /* function nextSkeleton(){

    riggedSkeletons[ currentRiggedSkeleton ].removeFromScene( scene );

    currentRiggedSkeleton ++;

    if( currentRiggedSkeleton === riggedSkeletons.length ){
      currentRiggedSkeleton = 0;
    }

    riggedSkeletons[ currentRiggedSkeleton ].addToScene( scene );

  }*/

  function onLoad(){


    loaded ++;

    if( loaded === neededToLoad ){

      init();
      animate();
      stream.play();

    }

  }
</script>


</body>
</html>
